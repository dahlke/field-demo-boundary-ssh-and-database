slug: managing-boundary-in-production-ssh-and-database
id: adnyt8negprv
type: track
title: 'Managing Boundary in Production: SSH and Database Access'
teaser: Learn how to take a blank canvas Boundary deployment and configure it for production usage.
description: |-
  In this track, you will take a blank canvas Boundary cluster, and learn how to get it ready for production. That
  includes configuring auth methods, accounts, users, groups, and roles. You will also learn how to manage targets,
  access to those targets, and how to log in and connect to them. At the end, you will learn how to manage sessions
  with Boundary, and take a tour of the Boundary Admin UI.
icon: https://storage.googleapis.com/instruqt-frontend/assets/hashicorp/tracks/boundary.png
tags:
- boundary
owner: hashicorp
developers:
- neil@hashicorp.com
private: true
published: true
show_timer: true
skipping_enabled: true
challenges:
- slug: getting-started-with-boundary
  id: ctko5pdbst2d
  type: challenge
  title: Getting Started With Boundary
  teaser: Familiarize yourself with Boundary resources, and set up your first scopes and users.
  notes:
  - type: text
    contents: |-
      Boundary is a tool for managing identity-based access for modern, dynamic infrastructure. Just as infrastructure
      itself can be complex, at first glance Boundary can seem complex as well. As a result, it's helpful to understand
      how Boundary organizes security principals and resources, as well as how it allows you define granular
      permissions to those principals.

      In this track, you will learn how to manage all the different principals and resources in Boundary, as well as
      how to leverage those resources to connect to a host via SSH, as well as a Postgres instance via TCP.
  - type: text
    contents: |-
      In this challenge, you will learn about the following Boundary resources.

      - *Scope*: Abstract permission boundary modeled as a container. A scope can contain scopes forming a tree.
      - *Organization*: Top-level container (scope) which owns zero to many projects and zero to many authentication methods. An organization inherits from scope allowing it to own zero to many groups, roles, policies, targets, host catalogs or credential stores.
      - *Project*: Child scope of an organization.
  - type: text
    contents: |-
      Boundary has already been
      [installed](https://learn.hashicorp.com/tutorials/boundary/getting-started-install?in=boundary/getting-started)
      for you. A Boundary Controller and a Boundary Worker are also already running.  If you are not familiar with
      installing Boundary, the reference architecture, or concepts like scopes, auth methods, users, accounts, and
      more - check out the [Install and Configure Boundary Track](TODO).
  - type: text
    contents: |-
      The Boundary cluster was initialized *without generated resources*...

      What are generated resources? When you run `boundary dev` or boundary `database init`, Boundary automatically
      generates a number of resources to make getting started easier. Default scopes, auth methods, user, account, and
      targets are just some of the resources Boundary will generate unless you tell it not to.
  - type: text
    contents: |-
      In a production or long-running environment, these resources are not necessary, but without them, managing
      Boundary from scratch isn't straightforward...
  - type: text
    contents: |-
      How do you create your first user and login to administer a Boundary deployment that has no authentication
      methods, users, accounts, etc.?

      You will learn that in this track.
  - type: text
    contents: |-
      This first challenge will focus on *scopes*.

      Scopes are a foundational part of Boundary. They allow users to partition resources and assign ownership of
      resources to principals. There are three types of scopes within Boundary:

      - *Global (`global`):* There is only one `global` scope. It is the entry point for initial administration/setup and to manage the org scopes.
      - *Org:* Under the `global` scope, you can create multiple org scopes. Orgs are used to hold IAM-related resources and project scopes.
      - *Project:* Under each org scope, you can create multiple project scopes. Projects are used to hold infrastructure-related resources.
  assignment: |-
    In this challenge, you're going to create an org scope and project scope, without admin or default role creation.
    You're going to specify a role for managing these scopes by selected users in a later challenge.

    In this track you will make use of a the [Recovery KMS Workflow](https://www.boundaryproject.io/docs/installing/no-gen-resources#recovery-kms-workflow).
    This allows you to use a key specifid to "recover" Boundary, but you can also use it to authenticate to Boundary
    and manage it as a "global" super user. This allows you to authenticate from the CLI or from Terraform in order to
    manage Boundary without any generated resources. The recovery block you will use is located at
    `/root/boundary-controller-recovery.hcl`.

    TODO: explain reference architecture

    ---

    # Setting Up Your Scopes

    While Boundary has been [initiialized](https://www.boundaryproject.io/docs/installing/no-gen-resources) for you,
    this instance is currently a blank slate. The first thing you'll need to do is create the `HashiCups Engineering`
    org scope inside the `global` scope. Notice that you are skipping the creation of the admin and default roles for
    the scope.  This allows you to more explitly control access to Boundary, rather than use generated resources.

    Create a new org under the `global` scope named "HashiCups Engineering".

    ```
    boundary scopes create -name "HashiCups Engineering" \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -scope-id global \
      -skip-admin-role-creation \
      -skip-default-role-creation
    ```

    Example output:

    ```
    Scope information:
      Created Time:        Thu, 08 Jul 2021 16:54:24 UTC
      ID:                  o_Sxjf9392Zv
      Name:                HashiCups Engineering
      Updated Time:        Thu, 08 Jul 2021 16:54:24 UTC
      Version:             1

      Scope (parent):
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>
    ```

    Grab the org scope ID from the output and store it in an environment variable.

    ```
    export ORG_SCOPE_ID=<ORG_SCOPE_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export ORG_SCOPE_ID=$ORG_SCOPE_ID" >> ~/.bashrc
    ```

    Create a new org under the new org scope named, "HashiCups Web App" using the org scope ID from above, again,
    without the admin or default roles being created.

    ```
    boundary scopes create \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -name "HashiCups Web App" \
      -scope-id $ORG_SCOPE_ID \
      -skip-admin-role-creation \
      -skip-default-role-creation
    ```

    Example output:

    ```
    Scope information:
      Created Time:        Thu, 15 Jul 2021 23:28:36 UTC
      ID:                  p_GmTM7HDptN
      Name:                HashiCups Web App
      Updated Time:        Thu, 15 Jul 2021 23:28:36 UTC
      Version:             1

      Scope (parent):
        ID:                o_QFjcosOF2O
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated...>
    ```

    Grab the project scope ID from the output and store it in an environment variable for later usage.

    ```
    export PROJECT_SCOPE_ID=<PROJECT_SCOPE_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export PROJECT_SCOPE_ID=$PROJECT_SCOPE_ID" >> ~/.bashrc
    ```

    You now have your two scopes ready to go and are ready to configure your initial users and roles.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  difficulty: advanced
  timelimit: 600
- slug: configure-auth-methods
  id: pqy8xx0haupd
  type: challenge
  title: Configure Auth Methods
  teaser: Learn to configure auth methods in Boundary for user authentication.
  notes:
  - type: text
    contents: |-
      In this challenge, you will learn about the following Boundary resource.

      - *Auth Methods*: a resource that provides a mechanism for users to authenticate to Boundary.
  - type: text
    contents: |-
      Auth methods are resources that provide a mechanism for users to authenticate to Boundary. An auth method
      contains accounts which link an individual user to a set of credentials and managed groups which groups accounts
      that satisfy criteria and can be used as principals in roles.

      Auth methods can be defined at either a `global` or org scope.
  assignment: |-
    Now that you have your org scope and project scope created, it's time to add your first auth method.

    Create an auth method in the `global` scope.

    ```
    boundary auth-methods create password \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -scope-id global \
      -name "global_auth_method" \
      -description "Password auth method for global scope."
    ```

    Example output:

    ```
    Auth Method information:
      Created Time:                Tue, 13 Jul 2021 00:16:01 UTC
      Description:                 Password auth method for global org.
      ID:                          ampw_kHH1Cb4vmy
      Name:                        global_auth_method
      Type:                        password
      Updated Time:                Tue, 13 Jul 2021 00:16:01 UTC
      Version:                     1

    <...truncated...>
    ```

    Grab the global auth method ID from the output and store it in an environment variable for later usage.

    ```
    export GLOBAL_AUTH_METHOD_ID=<GLOBAL_AUTH_METHOD_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export GLOBAL_AUTH_METHOD_ID=$GLOBAL_AUTH_METHOD_ID" >> ~/.bashrc
    ```

    Next, create an auth method in the org scope you created in the first challenge.

    ```
    boundary auth-methods create password \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -scope-id $ORG_SCOPE_ID \
      -name "hashicups_eng_auth_method" \
      -description "Password auth method for HashiCups Engineering org scope."
    ```

    Example output:

    ```
    Auth Method information:
      Created Time:                Thu, 08 Jul 2021 18:08:10 UTC
      Description:                 Password auth method for HashiCups Engineering org scope.
      ID:                          ampw_YXiGz3OWHI
      Name:                        hashicups_eng_auth_method
      Type:                        password
      Updated Time:                Thu, 08 Jul 2021 18:08:10 UTC
      Version:                     1

    <...truncated...>
    ```

    Grab the org auth method ID from the output and store it in an environment variable for later usage.

    ```
    export ORG_AUTH_METHOD_ID=<ORG_AUTH_METHOD_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export ORG_AUTH_METHOD_ID=$ORG_AUTH_METHOD_ID" >> ~/.bashrc
    ```

    Congratulations! You've created your first auth methods. Next, you'll need to create your first accounts.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  difficulty: advanced
  timelimit: 600
- slug: configure-your-first-roles
  id: qup9zxi31fyp
  type: challenge
  title: Configure Your First Roles
  teaser: Learn to set up your first roles in Boundary and view the UI.
  notes:
  - type: text
    contents: |-
      In this challenge, you will learn about the following Boundary resource.

      - *Role*: Collection of capabilities granted to any principal (user, group, or project) the role is assigned to. A role belongs to one and only one scope, and owns zero or more direct grants.
  - type: text
    contents: |-
      Roles in Boundary manage the permissions given to principals (*users* and *groups*).

      Boundary's permissions model is a composable, RBAC, allow-only model that attempts to marry flexibility with
      usability.

      At a very high level, permissions within Boundary are declared via grant strings and mapped to users via roles.
      You'll learn more about permissions in Boundary in this challenge.
  - type: text
    contents: |-
      Boundary has three principals (in this case, users) that exist by default in the `global` scope, and cannot be
      deleted: anonymous (`u_anon`), authenticate (`u_auth`), and recovery (`u_recovery`).

      In this challenge you will use `u_anon`, which represents users that are not authenticated with Boundary. This
      is useful for providing permissions to users who are not logged in, and want to inspect certain endpoints in
      Boundary to log in.
  - type: text
    contents: |-
      This is useful not only from the CLI, but the Boundary UI leverages the `u_anon` principal to display the scopes
      and auth methods to unauthenticated users.

      You'll get your first glimpse of the the UI in this challenge, too.
  - type: text
    contents: |-
      Don't worry. You'll learn to create your own principals (users and groups) later in this track. You'll also get
      a full tour of the Admin UI.
  assignment: |-
    Currently, Boundary is locked down. A user without access to the `recovery-config.hcl` file, would not even be able
    to see the scopes or auth methods that you just created. This means the average user is completely left in the
    dark when trying to authenticate.

    The first two roles you will created will allow anonymous (unauthenticated) users the ability to list scopes and
    their auth methods. Once you have created these two roles, you'll attach them to the `u_anon` principal, which
    will allow any user to discover how and where to log in.

    Since the Boundary UI leverages the `u_anon` principal at the login page, creating these roles also will allow
    you to start leveraging the Boundary UI.

    ---

    First, open the Boundary UI tab. You should see a white screen. This is because currently, Boundary is configured
    to not allow anonymous users the ability to see the scopes or the auth methods in boundary. To allow for users
    to see the auth methods in the `global` scope, you'll need to create an anonymous role in the `global` scope that
    can list the scopes, auth methods, and allow a user to see their account and update their password.

    Create the anonymous listing role in the `global` scope, with the name `global_anon_listing`.

    ```
    boundary roles create \
      -scope-id global \
      -name global_anon_listing
    ```

    Example output:

    ```
    Role information:
      Created Time:        Thu, 08 Jul 2021 18:15:12 UTC
      Grant Scope ID:      global
      ID:                  r_h28yjg9dhH
      Name:                global_anon_listing
      Updated Time:        Thu, 08 Jul 2021 18:15:12 UTC
      Version:             1

    <...truncated...>
    ```

    Grab the global anon listing ID from the output and store it in an environment variable for later usage.

    ```
    export GLOBAL_ANON_LISTING_ID=<GLOBAL_ANON_LISTING_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export GLOBAL_ANON_LISTING_ID=$GLOBAL_ANON_LISTING_ID" >> ~/.bashrc
    ```

    Then, add the required grants to the newly created role.

    A grant string has a form similar to: `id=<id>;type=<type>;actions=<action list>;output_fields=<fields list>`.

    Each grant string is a mapping that describes a resource or set of resources and the permissions that should be
    granted on them.

    There are currently two types of selectors:

    - An `id` field that indicates a specific resource or a wildcard to match all
    - A `type` field that indicates a specific resource type or a wildcard to match all; this might also be used to grant permissions on collections of resources

    For example - the first `grant` below: you will use a wildcard (`*`) grant for `id`, on the `auth-method` `type`,
    with the `actions` of `list` and `authenticate`. This will allow this role to see the auth methods in Boundary
    without being authenticated.

    ```
    boundary roles add-grants \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $GLOBAL_ANON_LISTING_ID \
      -grant "id=*;type=auth-method;actions=list,authenticate" \
      -grant "id=*;type=scope;actions=list,no-op" \
      -grant "id={{account.id}};actions=read,change-password"
    ```

    And then add the global anonymous listing ID to the `u_anon` principal that exists by default.

    ```
    boundary roles add-principals \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $GLOBAL_ANON_LISTING_ID \
      -principal "u_anon"
    ```

    Example output:

    ```
    Role information:
      Created Time:        Thu, 08 Jul 2021 18:15:12 UTC
      Grant Scope ID:      global
      ID:                  r_h28yjg9dhH
      Name:                global_anon_listing
      Updated Time:        Thu, 08 Jul 2021 18:17:10 UTC
      Version:             2

    <...truncated...>

    Role information:
      Created Time:        Thu, 08 Jul 2021 18:15:12 UTC
      Grant Scope ID:      global
      ID:                  r_h28yjg9dhH
      Name:                global_anon_listing
      Updated Time:        Thu, 08 Jul 2021 18:17:11 UTC
      Version:             3

    <...truncated...>
    ```

    If you go to the `Boundary UI` tab now and hit refresh in the top right corner, you should be able to see the
    global auth methods now.

    However, you'll notice that you still can't see the org auth method. To do that, you'll also need to create the
    anonymous listing role for org scope.

    ```
    boundary roles create \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -name "org_anon_listing" \
      -scope-id $ORG_SCOPE_ID
    ```

    Example output:

    ```
    Role information:
      Created Time:        Thu, 08 Jul 2021 18:18:26 UTC
      Grant Scope ID:      o_tc3qudleXh
      ID:                  r_u0dn7mU3uh
      Name:                org_anon_listing
      Updated Time:        Thu, 08 Jul 2021 18:18:26 UTC
      Version:             1

    <...truncated...>
    ```

    Grab the org anon listing ID from the output and store it in an environment variable for later usage.

    ```
    export ORG_ANON_LISTING_ID=<ORG_ANON_LISTING_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export ORG_ANON_LISTING_ID=$ORG_ANON_LISTING_ID" >> ~/.bashrc
    ```

    Add the required grants and principals to the org anonymous listing ID.

    ```
    boundary roles add-grants \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $ORG_ANON_LISTING_ID \
      -grant "id=*;type=auth-method;actions=list,authenticate" \
      -grant "type=scope;actions=list" \
      -grant "id={{account.id}};actions=read,change-password"

    boundary roles add-principals \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $ORG_ANON_LISTING_ID \
      -principal "u_anon"
    ```

    Example output:

    ```
    Role information:
      Created Time:        Thu, 08 Jul 2021 18:18:26 UTC
      Grant Scope ID:      o_tc3qudleXh
      ID:                  r_u0dn7mU3uh
      Name:                org_anon_listing
      Updated Time:        Thu, 08 Jul 2021 18:22:27 UTC
      Version:             2

      Scope:
        ID:                o_tc3qudleXh
        Name:              HashiCups
        Parent Scope ID:   global
        Type:              org

    <...truncated...>

    Role information:
      Created Time:        Thu, 08 Jul 2021 18:18:26 UTC
      Grant Scope ID:      o_tc3qudleXh
      ID:                  r_u0dn7mU3uh
      Name:                org_anon_listing
      Updated Time:        Thu, 08 Jul 2021 18:22:28 UTC
      Version:             3

    <...truncated...>
    ```

    You should now be able to list the auth methods for both the global and org scope, as well as see them in the
    Boundary UI. You're now ready to start configuring your admin users.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: configure-admin-accounts
  id: vdpbl5d060bx
  type: challenge
  title: Configure Admin Accounts
  teaser: Learn to configure accounts in Boundary for identity management.
  notes:
  - type: text
    contents: |-
      In this challenge, you will learn about the following Boundary resource.

      - *Account*: Represents a unique set of credentials issued from a configured auth method which can be used to establish the identity of a user.
  - type: text
    contents: |-
      Previously you learned how to create auth methods in Boundary. After you set up your auth methods in Boundary, you
      need to create some accounts.

      Accounts represent external notions of a particular entity. Among other use-cases, this mechanism allows for an
      easy way to switch users to new IdPs within the organization deploying Boundary.
  - type: text
    contents: You'll start with admin accounts, and will configure other types of accounts in later challenges.
  assignment: |-
    You'll need login accounts for an admin user for both of your auth methods. You'll use the username `admin`
    and the password `password` for both. Both of these values have been placed in your `~/.bashrc` file for you as
    `ADMIN_USERNAME` and `ADMIN_PASSWORD` to simplify and reduce the possibility of typos.

    ```
    boundary accounts create password \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -auth-method-id $GLOBAL_AUTH_METHOD_ID \
      -login-name $ADMIN_USERNAME \
      -password $ADMIN_PASSWORD
    ```

    Example output:

    ```
    Account information:
      Auth Method ID:      ampw_UgALwVLX8T
      Created Time:        Wed, 14 Jul 2021 01:11:21 UTC
      ID:                  acctpw_Zfl1eBkplk
      Type:                password
      Updated Time:        Wed, 14 Jul 2021 01:11:21 UTC
      Version:             1

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>
    ```

    Grab the account ID from the output and store it in an environment variable for later usage.

    ```
    export GLOBAL_ADMIN_USER_ACCOUNT_ID=<GLOBAL_ADMIN_USER_ACCOUNT_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export GLOBAL_ADMIN_USER_ACCOUNT_ID=$GLOBAL_ADMIN_USER_ACCOUNT_ID" >> ~/.bashrc
    ```

    TODO: try to log in here and see if it works?

    Then, create a login account for the admin user for the org auth method.

    ```
    boundary accounts create password \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -auth-method-id $ORG_AUTH_METHOD_ID \
      -login-name $ADMIN_USERNAME \
      -password $ADMIN_PASSWORD
    ```

    Example output:

    ```
    Account information:
      Auth Method ID:      ampw_YXiGz3OWHI
      Created Time:        Thu, 08 Jul 2021 18:09:35 UTC
      ID:                  acctpw_nTGqpEt4OK
      Type:                password
      Updated Time:        Thu, 08 Jul 2021 18:09:35 UTC
      Version:             1

      Scope:
        ID:                o_tc3qudleXh
        Name:              HashiCups Web App
        Parent Scope ID:   global
        Type:              org

    <...truncated...>
    ```

    Grab the account ID from the output and store it in an environment variable for later usage.

    ```
    export ORG_ADMIN_USER_ACCOUNT_ID=<ORG_ADMIN_USER_ACCOUNT_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export ORG_ADMIN_USER_ACCOUNT_ID=$ORG_ADMIN_USER_ACCOUNT_ID" >> ~/.bashrc
    ```

    You've created your first accounts. Next, you'll need to create your first users.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: configure-admin-users
  id: j986bk9afoar
  type: challenge
  title: Configure Admin Users
  teaser: Learn to setup the admin users in Boundary to seed your production deployment.
  notes:
  - type: text
    contents: |-
      In this challenge, you will learn about the following Boundary resource.

      - *User*: Any entity authorized to access Boundary using authentication credentials specific to one of the configured authentication methods. A user can belong to zero or more groups.
  - type: text
    contents: |-
      Users and groups in Boundary are collectively known as *principals*. Assigning *grants* on *roles* is performed
      through principal IDs; that is, the unique IDs of users, groups, or both.
  - type: text
    contents: |-
      Users in Boundary represent an internal notion of a particular entity (human, machine, etc.). Users can be
      correlated with one or more account resources via auth methods.
  assignment: |-
    Create a user and associate that user with both login accounts you just created. This user will also be the
    principal in the role you create in a future challenge.

    ```
    boundary users create \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -scope-id global \
      -name $ADMIN_USERNAME \
      -description "Admin user for global scope."
    ```

    Example output:

    ```
    User information:
      Created Time:        Wed, 14 Jul 2021 01:19:02 UTC
      Description:         Admin user for global scope.
      ID:                  u_8ZbkJa5Zkq
      Name:                admin
      Updated Time:        Wed, 14 Jul 2021 01:19:02 UTC
      Version:             1

    <...truncated...>
    ```

    Grab the global admin user ID from the output and store it in an environment variable for later usage.

    ```
    export GLOBAL_ADMIN_USER_ID=<GLOBAL_ADMIN_USER_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export GLOBAL_ADMIN_USER_ID=$GLOBAL_ADMIN_USER_ID" >> ~/.bashrc
    ```

    Then, add the newly created global user to the global account.

    ```
    boundary users add-accounts \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $GLOBAL_ADMIN_USER_ID \
      -account $GLOBAL_ADMIN_USER_ACCOUNT_ID
    ```

    Example output:

    ```
    User information:
      Created Time:        Wed, 14 Jul 2021 01:19:02 UTC
      Description:         Admin user for global scope.
      ID:                  u_8ZbkJa5Zkq
      Name:                admin
      Updated Time:        Wed, 14 Jul 2021 01:19:39 UTC
      Version:             2

    <...truncated...>
    ```

    You'll do the same now for the org scope. Create the user for the org scope.

    ```
    boundary users create \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -scope-id $ORG_SCOPE_ID \
      -name $ADMIN_USERNAME \
      -description "Admin user for HashiCups Engineering org scope."
    ```

    Example output:

    ```
    User information:
      Created Time:        Wed, 14 Jul 2021 01:20:24 UTC
      Description:         Admin user for HashiCups Engineering org scope.
      ID:                  u_GujSZDvIKR
      Name:                admin
      Updated Time:        Wed, 14 Jul 2021 01:20:24 UTC
      Version:             1

    <...truncated...>
    ```

    Grab the user ID from the output and store it in an environment variable for later usage.

    ```
    export ORG_ADMIN_USER_ID=<ORG_ADMIN_USER_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export ORG_ADMIN_USER_ID=$ORG_ADMIN_USER_ID" >> ~/.bashrc
    ```

    You'll now add the user to the account for the org scope similarly to how you did before.

    ```
    boundary users add-accounts \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $ORG_ADMIN_USER_ID \
      -account $ORG_ADMIN_USER_ACCOUNT_ID
    ```

    Example output:

    ```
    User information:
      Created Time:        Wed, 14 Jul 2021 01:20:24 UTC
      Description:         Admin user for HashiCups Engineering org scope.
      ID:                  u_GujSZDvIKR
      Name:                admin
      Updated Time:        Wed, 14 Jul 2021 01:21:00 UTC
      Version:             2

    <...truncated...>
    ```

    You have now created your users, and attached them to their respective accounts. It's time to associate those with
    some baseline roles.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: configure-admin-roles
  id: vojdkujfd7of
  type: challenge
  title: Configure Admin Roles
  teaser: Learn to setup the roles in Boundary for admin access to your scopes.
  notes:
  - type: text
    contents: |-
      Now that you have created the Admin accounts and users, you'll need to assign permissions to them so they
      can be leveraged for actually administering Boundary.
  - type: text
    contents: |-
      You have already created two admin users. One should have full admin privileges (global, org and project scopes)
      and one should be limited to having admin privileges in only the org and project scopes.
  - type: text
    contents: |-
      These roles are similar to the roles created for you if generation had not been skipped during
      `boundary database init` when executed with the `-skip-initial-login-role-creation` flag.
  - type: text
    contents: |-
      Declaring roles explicitly allows you to manage them independently and fully within Terraform or via the CLI. In doing so,
      you can precisely define their access.
  assignment: |-
    First, you'll want to create all the different admin roles, before attaching them to the user principals and
    accounts you created in previous challenges.

    Start by creating the `global` admin role.

    ```
    boundary roles create \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -scope-id global \
      -name "global_admin"
    ```

    Example output:

    ```
    Role information:
      Created Time:        Wed, 28 Jul 2021 00:19:55 UTC
      Grant Scope ID:      global
      ID:                  r_SvKKIc1cET
      Name:                global_admin
      Updated Time:        Wed, 28 Jul 2021 00:19:55 UTC
      Version:             1

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>
    ```

    Grab the global admin role ID from the output and store it in an environment variable for later usage.

    ```
    export GLOBAL_ADMIN_ROLE_ID=<GLOBAL_ADMIN_ROLE_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export GLOBAL_ADMIN_ROLE_ID=$GLOBAL_ADMIN_ROLE_ID" >> ~/.bashrc
    ```

    Create the org admin role.

    ```
    boundary roles create \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -name "org_admin" \
      -scope-id $ORG_SCOPE_ID
    ```

    Example output:

    ```
    Role information:
      Created Time:        Wed, 28 Jul 2021 00:20:35 UTC
      Grant Scope ID:      o_hWf0Qxaqed
      ID:                  r_rSx4YiFQlV
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:20:35 UTC
      Version:             1

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>
    ```

    Grab the org admin role ID from the output and store it in an environment variable for later usage.

    ```
    export ORG_ADMIN_ROLE_ID=<ORG_ADMIN_ROLE_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export ORG_ADMIN_ROLE_ID=$ORG_ADMIN_ROLE_ID" >> ~/.bashrc
    ```

    Create the project admin role.

    ```
    boundary roles create \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -name "project_admin" \
      -scope-id $PROJECT_SCOPE_ID
    ```

    Example output:

    ```
    Role information:
      Created Time:        Wed, 28 Jul 2021 00:21:24 UTC
      Grant Scope ID:      p_sXnGCxGZpT
      ID:                  r_2ONjKkE5Tp
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:21:24 UTC
      Version:             1

      Scope:
        ID:                o_hWf0Qxaqed
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated...>
    ```

    Grab the project admin role ID from the output and store it in an environment variable for later usage.

    ```
    export PROJECT_ADMIN_ROLE_ID=<PROJECT_ADMIN_ROLE_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export PROJECT_ADMIN_ROLE_ID=$PROJECT_ADMIN_ROLE_ID" >> ~/.bashrc
    ```

    ---

    Now that you have created all the roles that you'll need, it's time to assign the grants for their respective needs.

    Start with the global scope admin role.

    ```
    boundary roles add-grants \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $GLOBAL_ADMIN_ROLE_ID \
      -grant "id=*;type=*;actions=*"
    ```

    Example output:

    ```
    Role information:
      Created Time:        Wed, 28 Jul 2021 00:19:55 UTC
      Grant Scope ID:      global
      ID:                  r_SvKKIc1cET
      Name:                global_admin
      Updated Time:        Wed, 28 Jul 2021 00:23:31 UTC
      Version:             2

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>
    ```

    Note the grant `'id=*;type=*;actions=*'`. This represents administrative access, as it is allowed to perform any
    action on any type of resource.

    Do the same on the remaining two admin roles for the org and project scopes.

    ```
    boundary roles add-grants \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $ORG_ADMIN_ROLE_ID \
      -grant "id=*;type=*;actions=*;output_fields=*"

    boundary roles add-grants \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $PROJECT_ADMIN_ROLE_ID \
      -grant "id=*;type=*;actions=*;output_fields=*"
    ```

    Example output:

    ```
    Role information:
      Created Time:        Wed, 28 Jul 2021 00:20:35 UTC
      Grant Scope ID:      o_hWf0Qxaqed
      ID:                  r_rSx4YiFQlV
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:24:04 UTC
      Version:             2

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>

    Role information:
      Created Time:        Wed, 28 Jul 2021 00:21:24 UTC
      Grant Scope ID:      p_sXnGCxGZpT
      ID:                  r_2ONjKkE5Tp
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:24:04 UTC
      Version:             2

      Scope:
        ID:                o_hWf0Qxaqed
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated...>
    ```

    Now, with all the admin roles created and permissions assigned to each role, it's time for you to add the roles
    to the user principals you created previously.

    Since the global admin user will need admin privileges in the global, org and project scopes, you'll add all three
    of the roles you just created to that user.

    ```
    boundary roles add-principals \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $GLOBAL_ADMIN_ROLE_ID \
      -principal $GLOBAL_ADMIN_USER_ID

    boundary roles add-principals \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $ORG_ADMIN_ROLE_ID \
      -principal $GLOBAL_ADMIN_USER_ID

    boundary roles add-principals \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $PROJECT_ADMIN_ROLE_ID \
      -principal $GLOBAL_ADMIN_USER_ID
    ```

    Example output:

    ```
    Role information:
      Created Time:        Wed, 28 Jul 2021 00:19:55 UTC
      Grant Scope ID:      global
      ID:                  r_SvKKIc1cET
      Name:                global_admin
      Updated Time:        Wed, 28 Jul 2021 00:23:31 UTC
      Version:             2

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>

    Role information:
      Created Time:        Wed, 28 Jul 2021 00:20:35 UTC
      Grant Scope ID:      o_hWf0Qxaqed
      ID:                  r_rSx4YiFQlV
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:24:56 UTC
      Version:             3

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>

    Role information:
      Created Time:        Wed, 28 Jul 2021 00:21:24 UTC
      Grant Scope ID:      p_sXnGCxGZpT
      ID:                  r_2ONjKkE5Tp
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:24:56 UTC
      Version:             3

      Scope:
        ID:                o_hWf0Qxaqed
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated...>
    ```

    The second admin user doesn't need global scope admin access, so for the second admin user, you'll only attach the
    role that gives admin access for the org scope and the project scope.

    ```
    boundary roles add-principals \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $ORG_ADMIN_ROLE_ID \
      -principal $ORG_ADMIN_USER_ID

    boundary roles add-principals \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $PROJECT_ADMIN_ROLE_ID \
      -principal $ORG_ADMIN_USER_ID
    ```

    Example output:

    ```
    Role information:
      Created Time:        Wed, 28 Jul 2021 00:20:35 UTC
      Grant Scope ID:      o_hWf0Qxaqed
      ID:                  r_rSx4YiFQlV
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:27:10 UTC
      Version:             4

      Scope:
        ID:                global
        Name:              global
        Type:              global

    <...truncated...>

    Role information:
      Created Time:        Wed, 28 Jul 2021 00:21:24 UTC
      Grant Scope ID:      p_sXnGCxGZpT
      ID:                  r_2ONjKkE5Tp
      Name:                org_admin
      Updated Time:        Wed, 28 Jul 2021 00:27:10 UTC
      Version:             4

      Scope:
        ID:                o_hWf0Qxaqed
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated...>
    ```

    And you're done configuring your admin users! You can now log in as the admin user.

    # TODO: explain the keyring type, do this in the next challenge?

    ```
    boundary authenticate password \
      -auth-method-id $GLOBAL_AUTH_METHOD_ID \
      -keyring-type none \
      -login-name $ADMIN_USERNAME \
      -password $ADMIN_PASSWORD
    ```

    Example output:

    ```
    Authentication information:
      Account ID:      acctpw_aMSJti0TY0
      Auth Method ID:  ampw_5FRUN6zMcF
      Expiration Time: Wed, 04 Aug 2021 00:30:06 UTC
      User ID:         u_nysEVj7khR

    Storing the token in a keyring was disabled. The token is:
    at_6639zZVa89_s14EEyd7VtG32XtieNb3fedVAr31wgQ9gi7nGfjNnEb5MtngduqjC1P28x3jr8tdqunKaPtByfgeu9hPW8PTaStLoHmRJjtGjvDvASS6VuYbgJ4Y8FiS51
    Please be sure to store it safely!
    ```

    Grab the token from the output and store it in an environment variable for later usage.

    ```
    export BOUNDARY_TOKEN=<BOUNDARY_TOKEN>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export BOUNDARY_TOKEN=$BOUNDARY_TOKEN" >> ~/.bashrc
    ```

    You can also now log in through the Boundary UI using the admin username and password in either the global or org
    scopes. Feel free to take the UI for a spin before continuing.

    Congratulations! You have setup the initial resources in Boundary, and retrieved your first Boundary token. Next,
    you will learn to connect to your first target, before learning about defining different types of users, roles, and
    groups.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: configure-and-connect-to-your-first-target-with-ssh
  id: wm0enxxguhie
  type: challenge
  title: Configure and Connect to Your First Target with SSH
  teaser: Use Boundary as a TCP proxy to SSH to a remote host.
  notes:
  - type: text
    contents: |-
      In this challenge, you will learn about the following Boundary resources.

      - *Host*: Computing element with a network address reachable from Boundary.
      - *Host catalog*: Permission boundary modeled as a container containing scopes forming a tree.
      - *Host set*: Subset of hosts from the set of hosts of the host catalog it belongs to. A host set belongs to one and only one host; therefore, it gets deleted when its host catalog is deleted.
      - *Target*: Networked service a user can connect to and interact with through Boundary. A target can contain zero or more host sets.
  - type: text
    contents: |-
      A [host catalog](https://www.boundaryproject.io/docs/concepts/domain-model/host-catalogs) is a resource that
      contains hosts and host sets. A host catalog can only be defined within a project.
  - type: text
    contents: |-
      A [host set](https://www.boundaryproject.io/docs/concepts/domain-model/host-sets) is a resource that represents
      a collection of hosts which are considered equivalent for the purposes of access control. A host set can only
      include hosts from the same host catalog as the host set. A target can reference host sets from host catalogs
      which belong to the same project as the target.
  - type: text
    contents: |-
      A [host](https://www.boundaryproject.io/docs/concepts/domain-model/hosts) is a resource that represents a
      computing element with a network address reachable from Boundary. A host belongs to a host catalog. Hosts can
      only be associated with host sets from the same host catalog as the host.
  - type: text
    contents: |-
      A [target](https://www.boundaryproject.io/docs/concepts/domain-model/targets) is a resource that represents
      a networked service with an associated set of permissions a user can connect to and interact with through
      Boundary by way of a session. A target can only be defined within a project. A target can contain references to
      host sets from host catalogs which belong to the same project as the target.
  - type: text
    contents: |-
      When you put all it all together, targets are Boundary resources that contain one or more host sets. A target
      allows Boundary users to define an endpoint with a default port and a protocol to establish a session. Unless
      specified with a `-host-id` flag, Boundary will choose one Host in the host set to connect to at random.
  - type: text
    contents: |-
      TODO: add a diagram of the ref architecture and components to the notes and tell the user they can go view that
      if they need a refresher. Explain the existence of the boundary worker
  assignment: |-
    In this challenge you are going to create a host catalog, add a host set with a new host to it, define it as a
    target, and finally - connect to that host via Boundary.

    Up until now, you've been leveraging the Recovery KMS Workflow to create the anonymous listing users, as well
    as the admin users. Since you now have admin users to leverage, you wil no longer need that workflow as long as
    you are logged in as an admin user.

    ---

    You will use the project scope you created for this challenge. List the scopes you created for the org.

    ```
    boundary scopes list -scope-id $ORG_SCOPE_ID
    ```

    You should output similar to the below text.

    ```
    Scope information:
      ID:                    p_E5Hi8BQlJm
        Version:             1
        Name:                HashiCups App
        Authorized Actions:
          no-op
          read
          update
          delete
    ```

    You should recognize the "HashiCups App" project scope you created in the previous challenge. Currently, there
    are no targets in the scope. You can confirm that with the following command.

    ```
    boundary targets list -scope-id $PROJECT_SCOPE_ID
    ```

    Example output:

    ```
    No targets found
    ```

    At the end of this challenge, you will have a target that you can connect to, but first, you must configure
    a few things.

    The first thing you'll need to create is a *host catalog* named "HashiCups App" in the "HashiCups App" project
    scope.

    ```
    boundary host-catalogs create static \
      -scope-id $PROJECT_SCOPE_ID \
      -name "HashiCups Web App" \
      -description "For HashiCups Web App usage"
    ```

    Example output:

    ```
    Host Catalog information:
      Created Time:        Mon, 12 Jul 2021 16:48:28 UTC
      Description:         For HashiCups Web App usage
      ID:                  hcst_RVwh1LxNMa
      Name:                HashiCups Web App
      Type:                static
      Updated Time:        Mon, 12 Jul 2021 16:48:28 UTC
      Version:             1

    <...truncated..>
    ```

    Grab the host catalog ID from the output and store it in an environment variable for later usage.

    ```
    export PROJECT_HOST_CATALOG_ID=<PROJECT_HOST_CATALOG_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export PROJECT_HOST_CATALOG_ID=$PROJECT_HOST_CATALOG_ID" >> ~/.bashrc
    ```

    Next, create a new *host*. Note that the address you'll be using is `boundary-worker` which resolves to the
    Boundary worker node that you want to connect to.

    ```
    boundary hosts create static \
      -name  worker-host \
      -description "Boundary Worker host" \
      -address "boundary-worker" \
      -host-catalog-id $PROJECT_HOST_CATALOG_ID
    ```

    Example output:

    ```
    Host information:
      Created Time:        Mon, 12 Jul 2021 20:37:34 UTC
      Description:         Boundary Worker host
      Host Catalog ID:     hcst_cMzXXWNylL
      ID:                  hst_mnmBqpd9ky
      Name:                worker-host
      Type:                static
      Updated Time:        Mon, 12 Jul 2021 20:37:34 UTC
      Version:             1

    <...truncated..>
    ```

    Grab the host ID from the output and store it in an environment variable for later usage.

    ```
    export WORKER_HOST_ID=<WORKER_HOST_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export WORKER_HOST_ID=$WORKER_HOST_ID" >> ~/.bashrc
    ```

    A *host set* groups together hosts, which provide logically equivalent services. Targets work off of host sets,
    so even if there is only one hosts, you will still create a host set to contain one host.

    Create a host set named "test-machines".

    ```
    boundary host-sets create static \
      -name "test-machines" \
      -description "Test machine host set" \
      -host-catalog-id $PROJECT_HOST_CATALOG_ID
    ```

    Example output:

    ```
    Host Set information:
      Created Time:        Mon, 12 Jul 2021 21:19:47 UTC
      Description:         Test machine host set
      Host Catalog ID:     hcst_nsnTh5hZsc
      ID:                  hsst_mr3TQkIVdd
      Name:                test-machines
      Type:                static
      Updated Time:        Mon, 12 Jul 2021 21:19:47 UTC
      Version:             1

    <...truncated..>
    ```

    Grab the host set ID from the output and store it in an environment variable for later usage.

    ```
    export SSH_HOST_SET_ID=<SSH_HOST_SET_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export SSH_HOST_SET_ID=$SSH_HOST_SET_ID" >> ~/.bashrc
    ```

    Now you can add the hosts you created above to the host set.

    ```
    boundary host-sets add-hosts \
      -id $SSH_HOST_SET_ID \
      -host=$WORKER_HOST_ID
    ```

    Example output:

    ```
    Host Set information:
      Created Time:        Thu, 15 Jul 2021 19:59:29 UTC
      Description:         Test machine host set
      Host Catalog ID:     hcst_1ZjlMIfOyd
      ID:                  hsst_PKHzKx6sQu
      Name:                test-machines
      Type:                static
      Updated Time:        Thu, 15 Jul 2021 19:59:46 UTC
      Version:             2

    <...truncated..>
    ```

    With the hosts added to the host set and the host catalog, it's time to define the target that you will ultimately
    connect to. You'll create a target named "tests", set the default port to `22` for SSH, and set the session
    connection limit to `-1`, which allows unlimited connections.

    ```
    boundary targets create tcp \
      -name "ssh-test-targets" \
      -description "Test SSH target" \
      -default-port 22 \
      -scope-id $PROJECT_SCOPE_ID \
      -session-connection-limit "-1"
    ```

    Example output:

    ```
    Target information:
      Created Time:               Mon, 12 Jul 2021 20:46:41 UTC
      Description:                Test SSH target
      ID:                         ttcp_QWFzLzmVLK
      Name:                       ssh-test-targets
      Session Connection Limit:   -1
      Session Max Seconds:        28800
      Type:                       tcp
      Updated Time:               Mon, 12 Jul 2021 20:46:41 UTC
      Version:                    1

    <...truncated..>
    ```

    Grab the target ID from the output and store it in an environment variable for later usage.

    ```
    export SSH_TARGET_ID=<SSH_TARGET_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export SSH_TARGET_ID=$SSH_TARGET_ID" >> ~/.bashrc
    ```

    The last bit of configuration you'll need to complete is adding the host set you created above to the target you
    just created.

    ```
    boundary targets add-host-sets \
      -id $SSH_TARGET_ID \
      -host-set $SSH_HOST_SET_ID
    ```

    Example output:

    ```
    Host Set information:
      Created Time:        Mon, 12 Jul 2021 20:40:08 UTC
      Description:         Test machine host set
      Host Catalog ID:     hcst_cMzXXWNylL
      ID:                  hsst_pl5Yv1yf7Y
      Name:                test-machines
      Type:                static
      Updated Time:        Mon, 12 Jul 2021 20:46:31 UTC
      Version:             2

    <...truncated..>

    Host IDs:
      hst_mnmBqpd9ky
    ```

    And you're done configuring your target.  You can view the details of the target using the `targets read` command.
    Run the following command and confirm you see your host set added in the output.

    ```
    boundary targets read -id $SSH_TARGET_ID
    ```

    Example output:

    ```
    Target information:
      Created Time:               Wed, 30 Jun 2021 00:37:51 UTC
      Description:                Provides an initial target in Boundary
      ID:                         ttcp_s3ngxT2ofL
      Name:                       Generated target
      Session Connection Limit:   -1
      Session Max Seconds:        28800
      Type:                       tcp
      Updated Time:               Wed, 30 Jun 2021 00:37:51 UTC
      Version:                    1

    <...truncated..>

      Host Sets:
        Host Catalog ID:          hcst_jLHX9jl2kL
        ID:                       hsst_4eg3luVSyC

      Attributes:
        Default Port:             22
    ```

    You are ready to connect to the target. You can paste the target ID into the below command to connect.

    ```
    boundary connect ssh -target-id $SSH_TARGET_ID
    ```

    Be sure to respond `yes` when asked if you are sure you want to continue connecting. You will then be dropped
    into the shell for the `boundary-worker`, connecting your SSH session via Boundary.

    TODO: If you see an error, run the command again.

    TODO: Show that you are connected to the Worker really, by switching to the `Worker` tab and check the IP or create a file or something.

    You have now successfully connected to your first target using via SSH using Boundary! Next, you'll learn
    how to use Boundary to connect to a Postgres instance using TCP.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Worker
    type: terminal
    hostname: boundary-worker
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: configure-dba-group-accounts-users-and-roles
  id: niaptwmxppym
  type: challenge
  title: Configure DBA Group, Accounts, Users and Roles
  teaser: Configure a new group for DBAs who will need access to Postgres databases.
  notes:
  - type: text
    contents: |-
      Only admins in HashiCups Engineering have SSH access. However, the admins want to delegate Postgres access to
      DBAs... TODO.

      - Group: Collection of users used for access control. A group is owned by one and only one scope.
  - type: text
    contents: |-
      Now you have learned how to setup the initial resources in Boundary, how to log in, and how to connect to your
      first target, it's time to learn how to break up access for different groups and roles at HashiCups.
  - type: text
    contents: |-
      It is a policy in HashiCups Engineering that only admins are allowed SSH access to any hosts. However, there is
      an exception which allows any DBAs in the HashiCups Engineering org to access any Postgres database.
  - type: text
    contents: |-
      Since you already have learned how to do most of these individual steps, this challenge will be compressed and
      cover the creation of groups, accounts, users, and roles all in one.
  assignment: |-
    A group in Boundary is a resource that represents a collection of users that are treated equally for the purposes
    of access control. A group is a principal, which allows it to be assigned to roles. Roles assigned to a group are
    indirectly assigned to the users in the group, and users receive all permissions of the assigned roles.

    Groups can be defined at the Global, Organization, or Project scope.

    In this challenge, you'll create a group, one account for a DBA and one user for a DBA, as an example.

    TODO: for now this uses the recovery-config, but I should fix the admin user to use that.

    ---

    This time, you'll start out by creating a group for the "HashiCups Engineering DBAs" team, under the HashiCups
    Engineering org scope.

    ```
    boundary groups create \
      -name "dba" \
      -description "HashiCups Engineering DBAs" \
      -scope-id $ORG_SCOPE_ID
    ```

    Example output:

    ```
    Group information:
      Created Time:        Tue, 20 Jul 2021 00:08:58 UTC
      Description:         HashiCups Engineering DBAs
      ID:                  g_DcpYXCrI1t
      Name:                dba
      Updated Time:        Tue, 20 Jul 2021 00:08:58 UTC
      Version:             1

    <...truncated..>
    ```

    Grab the DBA group ID from the output and store it in an environment variable for later usage.

    ```
    export DBA_GROUP_ID=<DBA_GROUP_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export DBA_GROUP_ID=$DBA_GROUP_ID" >> ~/.bashrc
    ```

    Once you have the DBA group created, you'll need to create a role that will be attached to that group principal.
    Since this is not for admin users, they should have read-only permissions.

    ```
    boundary roles create \
      -scope-id $ORG_SCOPE_ID \
      -name "postgres-read-only" \
      -description "Role with read-only permission for Postgres."
    ```

    Grab the DBA group ID from the output and store it in an environment variable for later usage.

    ```
    export PG_READ_ONLY_ROLE_ID=<PG_READ_ONLY_ROLE_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export PG_READ_ONLY_ROLE_ID=$PG_READ_ONLY_ROLE_ID" >> ~/.bashrc
    ```

    ```
    boundary roles add-principals \
      -id $DBA_GROUP_ID \
      -principal $PG_READ_ONLY_ROLE_ID
    ```

    ```
    boundary roles add-grants \
      -id $PG_READ_ONLY_ROLE_ID \
      -grant "id=*;type=*;actions=read,list"
    ```

    Now that you have the group created, and associated the correct roles with it. It's time to create a login account
    for a DBA user.  You'll use the username `dbauser1` and the password `password` for both. Those  values have been
    placed in your environment for you as `DBA_USERNAME` and `DBA_PASSWORD`.

    Create the login account.

    ```
    boundary accounts create password \
      -login-name $DBA_USERNAME \
      -password $DBA_PASSWORD \
      -auth-method-id $ORG_AUTH_METHOD_ID
    ```

    Example output:

    ```
    Account information:
      Auth Method ID:      ampw_uud2jNvuD6
      Created Time:        Mon, 19 Jul 2021 17:18:12 UTC
      ID:                  acctpw_let91m7s2P
      Type:                password
      Updated Time:        Mon, 19 Jul 2021 17:18:12 UTC
      Version:             1

      Scope:
        ID:                o_V34d4dHLJx
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated..>
    ```

    Grab the DBA account ID from the output and store it in an environment variable for later usage.

    ```
    export DBA_USER_ACCOUNT_ID=<DBA_USER_ACCOUNT_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export DBA_USER_ACCOUNT_ID=$DBA_USER_ACCOUNT_ID" >> ~/.bashrc
    ```

    ```
    boundary users create \
      -name  $DBA_USERNAME \
      -description "An example DBA user." \
      -scope-id $ORG_SCOPE_ID
    ```

    Example output:

    ```
    User information:
      Created Time:        Mon, 19 Jul 2021 17:18:51 UTC
      Description:         An example DBA user.
      ID:                  u_DMMzCnpvbl
      Name:                dbauser1
      Updated Time:        Mon, 19 Jul 2021 17:18:51 UTC
      Version:             1

      Scope:
        ID:                o_V34d4dHLJx
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated..>
    ```

    Grab the DBA user ID from the output and store it in an environment variable for later usage.

    ```
    export DBA_USER_ID=<DBA_USER_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export DBA_USER_ID=$DBA_USER_ID" >> ~/.bashrc
    ```

    Add that user to the DBA account.

    ```
    boundary users set-accounts \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $DBA_USER_ID \
      -account=$DBA_USER_ACCOUNT_ID
    ```

    Example output:

    ```
    User information:
      Created Time:        Mon, 19 Jul 2021 17:18:51 UTC
      Description:         An example DBA user.
      ID:                  u_DMMzCnpvbl
      Name:                dbauser1
      Updated Time:        Mon, 19 Jul 2021 17:19:37 UTC
      Version:             2

      Scope:
        ID:                o_V34d4dHLJx
        Name:              HashiCups Engineering
        Parent Scope ID:   global
        Type:              org

    <...truncated..>
    ```

    Add the user to the group.

    ```
    boundary groups add-members \
      -recovery-config /root/boundary-controller-recovery.hcl \
      -id $DBA_GROUP_ID \
      -member=$DBA_USER_ID
    ```

    Example output:

    ```
    Group information:
      Created Time:        Mon, 19 Jul 2021 23:11:24 UTC
      Description:         HashiCups Engineering DBAs
      ID:                  g_BmGhIY4xXK
      Name:                dba
      Updated Time:        Mon, 19 Jul 2021 23:11:38 UTC
      Version:             2

    <...truncated..>
    ```

    Finally, confirm that you can log in with the DBA user's credentials.

    ```
    boundary authenticate password \
      -auth-method-id $ORG_AUTH_METHOD_ID \
      -keyring-type none \
      -login-name $DBA_USERNAME \
      -password $DBA_PASSWORD
    ```
    Example output:

    ```
    Authentication information:
      Account ID:      acctpw_WTD8UQBgWh
      Auth Method ID:  ampw_H7RbviPzRk
      Expiration Time: Thu, 05 Aug 2021 16:59:47 UTC
      User ID:         u_CD5SjsvIax

    Storing the token in a keyring was disabled. The token is:
    at_R9h53oyEfn_s1YQHhYBwFCy9qdpQUWiKZKxNq71bYnYVvAoMK5DLbjLro7nMksEqpW4qZvSqXfPS27zpqHg2EvXMfwjUGdG9eMq8yBLQCtjKCfR2zSUM8zbxoUfMnYK1fRhMb6gJKp
    Please be sure to store it safely!
    ```

    Note that you don't want to store this boundary token quite yet. You still have a bit more configuration to do
    that will need the admin user to accomplish.

    Congratulations! You have successfully set up your DBA group, assigned some policies, and added an account and
    user. You're ready to verify the permissions as the DBA user, and connect to your Postgres database.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: configure-and-connect-to-postgres-with-tcp
  id: 1ut7x9mfbihc
  type: challenge
  title: Configure and Connect to Postgres with TCP
  teaser: Use Boundary as a TCP proxy to connect to a Postgres instance.
  notes:
  - type: text
    contents: TODO
  assignment: |-
    Now that you have created a group and an example DBA user, you can configure the new targets that you will connect
    to.  All hosts must be part of a host set, both of which must be within a host catalog. Since you already created a
    host catalog for your SSH targets, you should reuse that one.

    ---

    Create a new host named "postgres" in the host catalog created earlier.

    ```
    boundary hosts create static \
      -name  postgres \
      -description "Postgres host" \
      -address "127.0.0.1" \
      -host-catalog-id $PROJECT_HOST_CATALOG_ID
    ```

    Example output:

    ```
    Host information:
      Created Time:        Tue, 20 Jul 2021 22:54:57 UTC
      Description:         Postgres host
      Host Catalog ID:     hcst_n47YuM1GHH
      ID:                  hst_SlpSfkv0Zc
      Name:                postgres
      Type:                static
      Updated Time:        Tue, 20 Jul 2021 22:54:57 UTC
      Version:             1

    <...truncated..>
    ```

    Grab the Postgres host ID from the output and store it in an environment variable for later usage.

    ```
    export POSTGRES_HOST_ID=<POSTGRES_HOST_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export POSTGRES_HOST_ID=$POSTGRES_HOST_ID" >> ~/.bashrc
    ```

    ```
    boundary host-sets create static \
      -name "test-postgres-host-set" \
      -description "Postgres machine host set" \
      -host-catalog-id $PROJECT_HOST_CATALOG_ID
    ```

    Example output:

    ```
    Host Set information:
      Created Time:        Wed, 21 Jul 2021 00:55:41 UTC
      Description:         Postgres machine host set
      Host Catalog ID:     hcst_Xo6sVeh7Xx
      ID:                  hsst_3Z3rznlr8C
      Name:                test-postgres-host-set
      Type:                static
      Updated Time:        Wed, 21 Jul 2021 00:55:41 UTC
      Version:             1

    <...truncated..>
    ```

    Grab the Postgres host set ID from the output and store it in an environment variable for later usage.

    ```
    export POSTGRES_HOST_SET_ID=<POSTGRES_HOST_SET_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export POSTGRES_HOST_SET_ID=$POSTGRES_HOST_SET_ID" >> ~/.bashrc
    ```

    ```
    boundary host-sets add-hosts \
      -id $POSTGRES_HOST_SET_ID \
      -host=$POSTGRES_HOST_ID
    ```

    Example output:

    ```
    Host Set information:
      Created Time:        Wed, 21 Jul 2021 00:55:41 UTC
      Description:         Postgres machine host set
      Host Catalog ID:     hcst_Xo6sVeh7Xx
      ID:                  hsst_3Z3rznlr8C
      Name:                test-postgres-host-set
      Type:                static
      Updated Time:        Wed, 21 Jul 2021 00:57:03 UTC
      Version:             2

    <...truncated..>
    ```

    ```
    boundary targets create tcp \
      -name "tests" \
      -description "Test target" \
      -default-port 5432 \
      -scope-id $PROJECT_SCOPE_ID \
      -session-connection-limit "-1"
    ```

    Example output:

    ```
    Target information:
      Created Time:               Wed, 21 Jul 2021 00:57:21 UTC
      Description:                Test target
      ID:                         ttcp_lUwoQUFcsi
      Name:                       tests
      Session Connection Limit:   -1
      Session Max Seconds:        28800
      Type:                       tcp
      Updated Time:               Wed, 21 Jul 2021 00:57:21 UTC
      Version:                    1

    <...truncated..>
    ```

    Grab the Postgres target ID from the output and store it in an environment variable for later usage.

    ```
    export POSTGRES_TARGET_ID=<POSTGRES_TARGET_ID>
    ```

    Then add it to the `~/.bashrc` file for usage in later challenges, or session refreshes.

    ```
    echo "export POSTGRES_TARGET_ID=$POSTGRES_TARGET_ID" >> ~/.bashrc
    ```

    ```
    boundary targets add-host-sets \
      -id $POSTGRES_TARGET_ID \
      -host-set $POSTGRES_HOST_SET_ID
    ```

    Example output:

    ```
    Target information:
      Created Time:               Wed, 21 Jul 2021 00:57:21 UTC
      Description:                Test target
      ID:                         ttcp_lUwoQUFcsi
      Name:                       tests
      Session Connection Limit:   -1
      Session Max Seconds:        28800
      Type:                       tcp
      Updated Time:               Wed, 21 Jul 2021 00:57:53 UTC
      Version:                    2

    <...truncated..>
    ```

    Connect to it...

    ```
    boundary connect postgres -target-id $POSTGRES_TARGET_ID
    ```

    TODO: throwing an SSL error
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: manage-sessions
  id: 6n8fgeuzipfy
  type: challenge
  title: Manage Sessions
  teaser: Learn how you can manage Boundary sessions.
  notes:
  - type: text
    contents: |-
      [Sessions](https://www.boundaryproject.io/docs/concepts/domain-model/sessions) are Boundary resources created
      when connecting to a target.

      A target allows Boundary users to define an endpoint with a protocol and default port to establish a session.
  assignment: |-
    TODO: log back in as the admin user.

    First, list your active sessions in the project scope. There should be none. Run the following in the
    `Controller [Terminal 1]` tab.

    ```
    boundary sessions list -scope-id $PROJECT_SCOPE_ID
    ```

    Example output:

    ```
    No sessions found
    ```

    Next, create you'll want to create a session in the `Controller [Terminal 1]` tab. Sessions are created whenever
    a connection to a target is established, so you should establish an SSH connection to the Worker node.

    ```
    boundary connect ssh -target-id $SSH_TARGET_ID
    ```

    TODO: fails on the first connection again.

    Once you have established your connection to the Worker node in the `Controller [Terminal 1]`, switch to the
    `Controller [Terminal 2]` tab and list the sessions again. You should now be able to see the session you created
    when you connected to the Worker node.

    ```
    boundary sessions list -scope-id $PROJECT_SCOPE_ID
    ```

    Example output:

    ```
    Session information:
      ID:                    s_RYZsdaQx3o
        Status:              active
        Created Time:        Thu, 29 Jul 2021 23:51:16 UTC
        Expiration Time:     Fri, 30 Jul 2021 07:51:16 UTC
        Updated Time:        Thu, 29 Jul 2021 23:51:16 UTC
        User ID:             u_qJpvjo26qd
        Target ID:           ttcp_w6xDbr3tpC
        Authorized Actions:
          no-op
          read
          read:self
          cancel
          cancel:self

    <...truncated...>
    ```

    Grab the session ID from the output and store it in an environment variable.

    ```
    export SESSION_ID=<SESSION_ID>
    ```

    No need to add it to the `~/.bashrc` file this time since sessions are highly ephemeral and it will be gone by
    the end of this track.

    Note that the status of the sessions is `active`. You can inspect the session by looking it up with it's ID to
    get more detailed information on the session. Try that now.

    ```
    boundary sessions read -id $SESSION_ID
    ```

    Example output:

    ```
    Session information:
      Auth Token ID:       at_nIQoAAj2Cv
      Created Time:        Thu, 29 Jul 2021 23:51:16 UTC
      Endpoint:            tcp://boundary-worker:22
      Expiration Time:     Fri, 30 Jul 2021 07:51:16 UTC
      Host ID:             hst_9XHceFpUWd
      Host Set ID:         hsst_8ZfC69e9E8
      ID:                  s_RYZsdaQx3o
      Status:              active
      Target ID:           ttcp_w6xDbr3tpC
      Type:                tcp
      Updated Time:        Thu, 29 Jul 2021 23:51:16 UTC
      User ID:             u_qJpvjo26qd
      Version:             2

    <...truncated...>
    ```

    If you detect unexpected activity from a session, you can force the cancellation of a session. The command to
    cancel the session looks very similar to the command to read the session.

    ```
    boundary sessions cancel -id $SESSION_ID
    ```

    Example output:

    ```
    Session information:
      Auth Token ID:       at_nIQoAAj2Cv
      Created Time:        Thu, 29 Jul 2021 23:51:16 UTC
      Endpoint:            tcp://boundary-worker:22
      Expiration Time:     Fri, 30 Jul 2021 07:51:16 UTC
      Host ID:             hst_9XHceFpUWd
      Host Set ID:         hsst_8ZfC69e9E8
      ID:                  s_RYZsdaQx3o
      Status:              canceling
      Target ID:           ttcp_w6xDbr3tpC
      Type:                tcp
      Updated Time:        Fri, 30 Jul 2021 00:12:00 UTC
      User ID:             u_qJpvjo26qd
      Version:             3

    <...truncated...>
    ```

    Note the status is now `canceling`.

    ## Advanced session establishment (TODO: separate challenge?)

    In addition to the `boundary connect` command, you can create a session to a target and connect to that session in
    separate steps. This is accomplished using the `boundary targets authorize-session` command, which generates an
    authorization token that a user can use to start a session via `boundary connect -authz-token` at their own
    convenience.

    TODO: why would they want this? Why is it a proxy?

    _NOTE: In the absence of the `-host-id` flag, Boundary will pick a host from the host set if there is more than one
    host set attached to the target._

    ```
    boundary targets authorize-session -id $SSH_TARGET_ID -host-id $WORKER_HOST_ID
    ```

    Example output:

    ```
    TODO
    Target information:
      Authorization Token:
      CnixvX3sBZ<...truncated...>u7rBNtzaCEGgTB
      Created Time:          Fri, 30 Jul 2021 00:14:42 UTC
      Endpoint:              tcp://boundary-worker:22
      Host ID:               hst_9XHceFpUWd
      Scope ID:              p_XR52FbugKs
      Session ID:            s_95zkTCYff6
      Target ID:             ttcp_w6xDbr3tpC
      Type:                  tcp
      User ID:               u_qJpvjo26qd
    ```

    Copy the generated `Authorization Token` value. In the `Controller [Terminal 1]`` tab, establish the connection

    ```
    boundary connect -authz-token=<AUTHORIZATION_TOKEN>
    ```

    Example output:

    ```
    Proxy listening information:
      Address:             127.0.0.1
      Connection Limit:    -1
      Expiration:          Fri, 30 Jul 2021 08:14:42 UTC
      Port:                45291
      Protocol:            tcp
      Session ID:          s_95zkTCYff6
    ```

    With the above address and port information, you can connect to the local proxy and have your tcp traffic sent
    through the Boundary system.

    ```
    ssh <ADDRESS_FROM_ABOVE> -p <PORT_FROM_ABOVE>
    ```

    Example:

    ```
    ssh 127.0.0.1 -p 45291
    ```

    Congratulations! You now know how to manage session in Boundary. The last step of this track encourages you to
    take the UI for a spin. It is encouraged that you do so, but not required.
  tabs:
  - title: Controller [Terminal 1]
    type: terminal
    hostname: boundary-controller
  - title: Controller [Terminal 2]
    type: terminal
    hostname: boundary-controller
  - title: Worker
    type: terminal
    hostname: boundary-worker
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  difficulty: advanced
  timelimit: 600
- slug: explore-the-admin-ui
  id: wyaxsa25ysd1
  type: challenge
  title: Explore the Admin UI
  teaser: Get familiar with the Boundary Admin UI and explore what you created.
  notes:
  - type: text
    contents: |-
      Boundary enables simple and secure access to dynamic infrastructure by:

      - Identity-based access controls: Streamline just-in-time access to privileged sessions (e.g. TCP, SSH, RDP) for users and applications. Tightly control access permissions with extensible role-based access controls.
      - Access Automation: Define your perimeter of resources, identities, and access controls as code through Boundary's fully-instrumented Terraform Provider, REST API, CLI, and SDK. Automate the discovery of new resources and enforcement of existing policies as resources are provisioned.
      - Session Visibility: Security administrators gain monitor and managed the privileged sessions established with Boundary. Export session logs to your analytics tool of choice.

      In this track, you will learn how to use Boundary to dynamically access hosts via SSH, as well as remote Postgres database access.
  - type: text
    contents: Traditional approaches like SSH bastion hosts or VPNs that require distributing and managing credentials, configure network controls like firewalls, and expose the private network. Boundary provides a secure way to access to hosts and critical systems without having to manage credentials or expose your network.
  - type: text
    contents: "| Resource | Description |\n| --- | --- |\n| Scope\t| Abstract permission boundary modeled as a container. A scope can contain scopes forming a tree. |\n| Organization | Top-level container (scope) which owns zero to many projects and zero to many authentication methods. An organization inherits from scope allowing it to own zero to many groups, roles, policies, targets, host catalogs or credential stores. |\n| Project\t| Child scope of an organization. |\n| User | Any entity authorized to access Boundary using authentication credentials specific to one of the configured authentication methods. A user can belong to zero or more groups. |\n| Group\t| Collection of users used for access control. A group is owned by one and only one scope. |\n| Role | Collection of capabilities granted to any principal (user, group, or project) the role is assigned to. A role belongs to one and only one scope, and owns zero or more direct grants |\n| Host | Computing element with a network address reachable from Boundary. |\n| Host catalog | Permission boundary modeled as a container containing scopes forming a tree. |\n| Host set |Subset of hosts from the set of hosts of the host catalog it belongs to. A host set belongs to one and only one host; therefore, it gets deleted when its host catalog is deleted. |\n| Target | Networked service a user can connect to and interact with through Boundary. A target can contain zero or more host sets. |"
  - type: text
    contents: '''TODO: Explain Controllers vs Workers and show/ reference architecture.'''
  - type: text
    contents: |-
      TODO: clean this up
      The Manage Scopes tutorial demonstrated the steps to create a new org (IT_Support) and a project (QA_Tests) under the org.

      The Manage Targets tutorial demonstrated the creation of a host catalog, a host set, and hosts. Then, associated the host set to a target.

      You also enabled a new authorization method (password) for the IT_Support org and created a new user in the Manage Users and Groups tutorial. The Manage Roles and Permissions tutorial showed you how to create a role and assign a grant which specifies a set of permissions.

      Finally, the Manage Sessions tutorial demonstrated session management based on the target you defined for the QA_Tests project.
  assignment: |-
    # Explore the Admin Console

    Boundary's Admin Console provides an easy way to manage resources. Now that you have learned how to use Boundary to
    securely access any dynamic infrastructure, you should take a tour of the console to understand all the components.

    ## Exploring Roles, Principals and Grants in the Admin UI

    Open the Boundary UI tab. You should see a login screen. Use the global admin user you created earlier. Select
    the `global_auth_method` and use `admin` for the username and `password` for the password.

    TODO: update this for the script above, not dev mode.

    Once you have logged in, you will see the home screen containing all the top level resources in Boundary. Select
    *Roles* in the left sidebar, then select the "Administration" role.

    Notice that `admin` user is listed. *User*, *group*, and *project* are a type of principal which can be assigned to
    roles.

    Click on the *Grants* tab to view the permissions allowed on this role.  Grants represent strings of actions on
    resources: `id=<resource_id>; action=<actions>`

    The grant for Administration role indicates that all actions (`actions=*`) on all resources (`id=*;type=*`) are
    permitted. Refer to the [documentation](https://www.boundaryproject.io/docs/concepts/security/permissions#permission-grant-formats)
    for more details.

    Return to the *Roles* list and select *Login and Default Grants* role.  Click *Grants* to view its permissions.

    A role can have multiple grants defined. Those grants are deleted when the role is deleted. A grant is also deleted
    if its associated resource is deleted.

    Select *Projects* and then *Generated project scope*. Notice that you can see *Sessions*, *Targets* and
    *Host Catalogs*.

    Select *Host Catalogs -> Generated host catalog -> Host Sets -> Generated host set* to view the details of the
    *Host Set*. You can then select the *Hosts* tab to view attached hosts.

    ---

    Now that you have taken a tour of the admin UI and understand the generated resources, you are ready to connect
    to your first target via Boundary.
  tabs:
  - title: Controller
    type: terminal
    hostname: boundary-controller
  - title: Boundary UI
    type: service
    hostname: boundary-controller
    port: 9200
  - title: VS Code
    type: service
    hostname: boundary-controller
    port: 8443
  difficulty: advanced
  timelimit: 600
checksum: "4916763994698307783"
